// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.3
// source: block/v1/block.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Block_ValidateAddress_FullMethodName        = "/api.block.v1.Block/ValidateAddress"
	Block_GetTokenBalance_FullMethodName        = "/api.block.v1.Block/GetTokenBalance"
	Block_GetTokenBalanceBatch_FullMethodName   = "/api.block.v1.Block/GetTokenBalanceBatch"
	Block_GetTokenInfo_FullMethodName           = "/api.block.v1.Block/GetTokenInfo"
	Block_GetTokenInfoBatch_FullMethodName      = "/api.block.v1.Block/GetTokenInfoBatch"
	Block_GetTokenPrice_FullMethodName          = "/api.block.v1.Block/GetTokenPrice"
	Block_GetTokenPriceBatch_FullMethodName     = "/api.block.v1.Block/GetTokenPriceBatch"
	Block_Swap_FullMethodName                   = "/api.block.v1.Block/Swap"
	Block_Quote_FullMethodName                  = "/api.block.v1.Block/Quote"
	Block_Transfer_FullMethodName               = "/api.block.v1.Block/Transfer"
	Block_Approve_FullMethodName                = "/api.block.v1.Block/Approve"
	Block_SendTransaction_FullMethodName        = "/api.block.v1.Block/SendTransaction"
	Block_SendPrivateTransaction_FullMethodName = "/api.block.v1.Block/SendPrivateTransaction"
	Block_CreateAddress_FullMethodName          = "/api.block.v1.Block/CreateAddress"
	Block_CreateAddressBatch_FullMethodName     = "/api.block.v1.Block/CreateAddressBatch"
	Block_GetTransactionByHash_FullMethodName   = "/api.block.v1.Block/GetTransactionByHash"
	Block_GetLiquidity_FullMethodName           = "/api.block.v1.Block/GetLiquidity"
	Block_GetPendingNonce_FullMethodName        = "/api.block.v1.Block/GetPendingNonce"
	Block_GetTokenSecurity_FullMethodName       = "/api.block.v1.Block/GetTokenSecurity"
	Block_GetTokenMedia_FullMethodName          = "/api.block.v1.Block/GetTokenMedia"
	Block_GetTokenPoolInfo_FullMethodName       = "/api.block.v1.Block/GetTokenPoolInfo"
)

// BlockClient is the client API for Block service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockClient interface {
	// 验证地址
	ValidateAddress(ctx context.Context, in *ValidateAddressRequest, opts ...grpc.CallOption) (*ValidateAddressReply, error)
	// 代币模块
	GetTokenBalance(ctx context.Context, in *GetTokenBalanceRequest, opts ...grpc.CallOption) (*GetTokenBalanceReply, error)
	GetTokenBalanceBatch(ctx context.Context, in *GetTokenBalanceBatchRequest, opts ...grpc.CallOption) (*GetTokenBalanceBatchReply, error)
	GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoReply, error)
	GetTokenInfoBatch(ctx context.Context, in *GetTokenInfoBatchRequest, opts ...grpc.CallOption) (*GetTokenInfoBatchReply, error)
	GetTokenPrice(ctx context.Context, in *GetTokenPriceRequest, opts ...grpc.CallOption) (*GetTokenPriceReply, error)
	GetTokenPriceBatch(ctx context.Context, in *GetTokenPriceBatchRequest, opts ...grpc.CallOption) (*GetTokenPriceBatchReply, error)
	// 闪兑 返回RawTx交易数组 EVM包含Approve操作
	Swap(ctx context.Context, in *SwapRequest, opts ...grpc.CallOption) (*SwapReply, error)
	Quote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteReply, error)
	// 转账 返回RawTx交易
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferReply, error)
	// 授权 返回RawTx交易 EVM
	Approve(ctx context.Context, in *ApproveRequest, opts ...grpc.CallOption) (*ApproveReply, error)
	// 广播交易上链
	SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*SendTransactionReply, error)
	SendPrivateTransaction(ctx context.Context, in *SendPrivateTransactionRequest, opts ...grpc.CallOption) (*SendPrivateTransactionReply, error)
	CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error)
	CreateAddressBatch(ctx context.Context, in *CreateAddressBatchRequest, opts ...grpc.CallOption) (*CreateAddressBatchReply, error)
	// 获取交易信息
	GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*GetTransactionByHashReply, error)
	// 获取流动性
	GetLiquidity(ctx context.Context, in *GetLiquidityRequest, opts ...grpc.CallOption) (*GetLiquidityReply, error)
	// 获取未使用Nonce EVM
	GetPendingNonce(ctx context.Context, in *GetPendingNonceRequest, opts ...grpc.CallOption) (*GetPendingNonceReply, error)
	// 获取代币安全信息
	GetTokenSecurity(ctx context.Context, in *GetTokenSecurityRequest, opts ...grpc.CallOption) (*GetTokenSecurityReply, error)
	// 获取代币媒体信息
	GetTokenMedia(ctx context.Context, in *GetTokenMediaRequest, opts ...grpc.CallOption) (*GetTokenMediaReply, error)
	GetTokenPoolInfo(ctx context.Context, in *GetTokenPoolInfoRequest, opts ...grpc.CallOption) (*GetTokenPoolInfoReply, error)
}

type blockClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockClient(cc grpc.ClientConnInterface) BlockClient {
	return &blockClient{cc}
}

func (c *blockClient) ValidateAddress(ctx context.Context, in *ValidateAddressRequest, opts ...grpc.CallOption) (*ValidateAddressReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateAddressReply)
	err := c.cc.Invoke(ctx, Block_ValidateAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenBalance(ctx context.Context, in *GetTokenBalanceRequest, opts ...grpc.CallOption) (*GetTokenBalanceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenBalanceReply)
	err := c.cc.Invoke(ctx, Block_GetTokenBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenBalanceBatch(ctx context.Context, in *GetTokenBalanceBatchRequest, opts ...grpc.CallOption) (*GetTokenBalanceBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenBalanceBatchReply)
	err := c.cc.Invoke(ctx, Block_GetTokenBalanceBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenInfoReply)
	err := c.cc.Invoke(ctx, Block_GetTokenInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenInfoBatch(ctx context.Context, in *GetTokenInfoBatchRequest, opts ...grpc.CallOption) (*GetTokenInfoBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenInfoBatchReply)
	err := c.cc.Invoke(ctx, Block_GetTokenInfoBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenPrice(ctx context.Context, in *GetTokenPriceRequest, opts ...grpc.CallOption) (*GetTokenPriceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenPriceReply)
	err := c.cc.Invoke(ctx, Block_GetTokenPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenPriceBatch(ctx context.Context, in *GetTokenPriceBatchRequest, opts ...grpc.CallOption) (*GetTokenPriceBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenPriceBatchReply)
	err := c.cc.Invoke(ctx, Block_GetTokenPriceBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) Swap(ctx context.Context, in *SwapRequest, opts ...grpc.CallOption) (*SwapReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwapReply)
	err := c.cc.Invoke(ctx, Block_Swap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) Quote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuoteReply)
	err := c.cc.Invoke(ctx, Block_Quote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferReply)
	err := c.cc.Invoke(ctx, Block_Transfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) Approve(ctx context.Context, in *ApproveRequest, opts ...grpc.CallOption) (*ApproveReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveReply)
	err := c.cc.Invoke(ctx, Block_Approve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*SendTransactionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendTransactionReply)
	err := c.cc.Invoke(ctx, Block_SendTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) SendPrivateTransaction(ctx context.Context, in *SendPrivateTransactionRequest, opts ...grpc.CallOption) (*SendPrivateTransactionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendPrivateTransactionReply)
	err := c.cc.Invoke(ctx, Block_SendPrivateTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAddressReply)
	err := c.cc.Invoke(ctx, Block_CreateAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) CreateAddressBatch(ctx context.Context, in *CreateAddressBatchRequest, opts ...grpc.CallOption) (*CreateAddressBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAddressBatchReply)
	err := c.cc.Invoke(ctx, Block_CreateAddressBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*GetTransactionByHashReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionByHashReply)
	err := c.cc.Invoke(ctx, Block_GetTransactionByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetLiquidity(ctx context.Context, in *GetLiquidityRequest, opts ...grpc.CallOption) (*GetLiquidityReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLiquidityReply)
	err := c.cc.Invoke(ctx, Block_GetLiquidity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetPendingNonce(ctx context.Context, in *GetPendingNonceRequest, opts ...grpc.CallOption) (*GetPendingNonceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPendingNonceReply)
	err := c.cc.Invoke(ctx, Block_GetPendingNonce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenSecurity(ctx context.Context, in *GetTokenSecurityRequest, opts ...grpc.CallOption) (*GetTokenSecurityReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenSecurityReply)
	err := c.cc.Invoke(ctx, Block_GetTokenSecurity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenMedia(ctx context.Context, in *GetTokenMediaRequest, opts ...grpc.CallOption) (*GetTokenMediaReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenMediaReply)
	err := c.cc.Invoke(ctx, Block_GetTokenMedia_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockClient) GetTokenPoolInfo(ctx context.Context, in *GetTokenPoolInfoRequest, opts ...grpc.CallOption) (*GetTokenPoolInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenPoolInfoReply)
	err := c.cc.Invoke(ctx, Block_GetTokenPoolInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockServer is the server API for Block service.
// All implementations must embed UnimplementedBlockServer
// for forward compatibility.
type BlockServer interface {
	// 验证地址
	ValidateAddress(context.Context, *ValidateAddressRequest) (*ValidateAddressReply, error)
	// 代币模块
	GetTokenBalance(context.Context, *GetTokenBalanceRequest) (*GetTokenBalanceReply, error)
	GetTokenBalanceBatch(context.Context, *GetTokenBalanceBatchRequest) (*GetTokenBalanceBatchReply, error)
	GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoReply, error)
	GetTokenInfoBatch(context.Context, *GetTokenInfoBatchRequest) (*GetTokenInfoBatchReply, error)
	GetTokenPrice(context.Context, *GetTokenPriceRequest) (*GetTokenPriceReply, error)
	GetTokenPriceBatch(context.Context, *GetTokenPriceBatchRequest) (*GetTokenPriceBatchReply, error)
	// 闪兑 返回RawTx交易数组 EVM包含Approve操作
	Swap(context.Context, *SwapRequest) (*SwapReply, error)
	Quote(context.Context, *QuoteRequest) (*QuoteReply, error)
	// 转账 返回RawTx交易
	Transfer(context.Context, *TransferRequest) (*TransferReply, error)
	// 授权 返回RawTx交易 EVM
	Approve(context.Context, *ApproveRequest) (*ApproveReply, error)
	// 广播交易上链
	SendTransaction(context.Context, *SendTransactionRequest) (*SendTransactionReply, error)
	SendPrivateTransaction(context.Context, *SendPrivateTransactionRequest) (*SendPrivateTransactionReply, error)
	CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error)
	CreateAddressBatch(context.Context, *CreateAddressBatchRequest) (*CreateAddressBatchReply, error)
	// 获取交易信息
	GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*GetTransactionByHashReply, error)
	// 获取流动性
	GetLiquidity(context.Context, *GetLiquidityRequest) (*GetLiquidityReply, error)
	// 获取未使用Nonce EVM
	GetPendingNonce(context.Context, *GetPendingNonceRequest) (*GetPendingNonceReply, error)
	// 获取代币安全信息
	GetTokenSecurity(context.Context, *GetTokenSecurityRequest) (*GetTokenSecurityReply, error)
	// 获取代币媒体信息
	GetTokenMedia(context.Context, *GetTokenMediaRequest) (*GetTokenMediaReply, error)
	GetTokenPoolInfo(context.Context, *GetTokenPoolInfoRequest) (*GetTokenPoolInfoReply, error)
	mustEmbedUnimplementedBlockServer()
}

// UnimplementedBlockServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBlockServer struct{}

func (UnimplementedBlockServer) ValidateAddress(context.Context, *ValidateAddressRequest) (*ValidateAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAddress not implemented")
}
func (UnimplementedBlockServer) GetTokenBalance(context.Context, *GetTokenBalanceRequest) (*GetTokenBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenBalance not implemented")
}
func (UnimplementedBlockServer) GetTokenBalanceBatch(context.Context, *GetTokenBalanceBatchRequest) (*GetTokenBalanceBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenBalanceBatch not implemented")
}
func (UnimplementedBlockServer) GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfo not implemented")
}
func (UnimplementedBlockServer) GetTokenInfoBatch(context.Context, *GetTokenInfoBatchRequest) (*GetTokenInfoBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfoBatch not implemented")
}
func (UnimplementedBlockServer) GetTokenPrice(context.Context, *GetTokenPriceRequest) (*GetTokenPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenPrice not implemented")
}
func (UnimplementedBlockServer) GetTokenPriceBatch(context.Context, *GetTokenPriceBatchRequest) (*GetTokenPriceBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenPriceBatch not implemented")
}
func (UnimplementedBlockServer) Swap(context.Context, *SwapRequest) (*SwapReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Swap not implemented")
}
func (UnimplementedBlockServer) Quote(context.Context, *QuoteRequest) (*QuoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quote not implemented")
}
func (UnimplementedBlockServer) Transfer(context.Context, *TransferRequest) (*TransferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedBlockServer) Approve(context.Context, *ApproveRequest) (*ApproveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Approve not implemented")
}
func (UnimplementedBlockServer) SendTransaction(context.Context, *SendTransactionRequest) (*SendTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTransaction not implemented")
}
func (UnimplementedBlockServer) SendPrivateTransaction(context.Context, *SendPrivateTransactionRequest) (*SendPrivateTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPrivateTransaction not implemented")
}
func (UnimplementedBlockServer) CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddress not implemented")
}
func (UnimplementedBlockServer) CreateAddressBatch(context.Context, *CreateAddressBatchRequest) (*CreateAddressBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddressBatch not implemented")
}
func (UnimplementedBlockServer) GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*GetTransactionByHashReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (UnimplementedBlockServer) GetLiquidity(context.Context, *GetLiquidityRequest) (*GetLiquidityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiquidity not implemented")
}
func (UnimplementedBlockServer) GetPendingNonce(context.Context, *GetPendingNonceRequest) (*GetPendingNonceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPendingNonce not implemented")
}
func (UnimplementedBlockServer) GetTokenSecurity(context.Context, *GetTokenSecurityRequest) (*GetTokenSecurityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenSecurity not implemented")
}
func (UnimplementedBlockServer) GetTokenMedia(context.Context, *GetTokenMediaRequest) (*GetTokenMediaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenMedia not implemented")
}
func (UnimplementedBlockServer) GetTokenPoolInfo(context.Context, *GetTokenPoolInfoRequest) (*GetTokenPoolInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenPoolInfo not implemented")
}
func (UnimplementedBlockServer) mustEmbedUnimplementedBlockServer() {}
func (UnimplementedBlockServer) testEmbeddedByValue()               {}

// UnsafeBlockServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockServer will
// result in compilation errors.
type UnsafeBlockServer interface {
	mustEmbedUnimplementedBlockServer()
}

func RegisterBlockServer(s grpc.ServiceRegistrar, srv BlockServer) {
	// If the following call pancis, it indicates UnimplementedBlockServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Block_ServiceDesc, srv)
}

func _Block_ValidateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).ValidateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_ValidateAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).ValidateAddress(ctx, req.(*ValidateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenBalance(ctx, req.(*GetTokenBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenBalanceBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenBalanceBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenBalanceBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenBalanceBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenBalanceBatch(ctx, req.(*GetTokenBalanceBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenInfo(ctx, req.(*GetTokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenInfoBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenInfoBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenInfoBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenInfoBatch(ctx, req.(*GetTokenInfoBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenPrice(ctx, req.(*GetTokenPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenPriceBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenPriceBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenPriceBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenPriceBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenPriceBatch(ctx, req.(*GetTokenPriceBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_Swap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).Swap(ctx, req.(*SwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_Quote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).Quote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_Quote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).Quote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_Transfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_Approve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).Approve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_Approve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).Approve(ctx, req.(*ApproveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_SendTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).SendTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_SendTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).SendTransaction(ctx, req.(*SendTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_SendPrivateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPrivateTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).SendPrivateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_SendPrivateTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).SendPrivateTransaction(ctx, req.(*SendPrivateTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_CreateAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).CreateAddress(ctx, req.(*CreateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_CreateAddressBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).CreateAddressBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_CreateAddressBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).CreateAddressBatch(ctx, req.(*CreateAddressBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTransactionByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTransactionByHash(ctx, req.(*GetTransactionByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetLiquidity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetLiquidity(ctx, req.(*GetLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetPendingNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPendingNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetPendingNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetPendingNonce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetPendingNonce(ctx, req.(*GetPendingNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenSecurityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenSecurity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenSecurity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenSecurity(ctx, req.(*GetTokenSecurityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenMediaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenMedia_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenMedia(ctx, req.(*GetTokenMediaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Block_GetTokenPoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenPoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServer).GetTokenPoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Block_GetTokenPoolInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServer).GetTokenPoolInfo(ctx, req.(*GetTokenPoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Block_ServiceDesc is the grpc.ServiceDesc for Block service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Block_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.block.v1.Block",
	HandlerType: (*BlockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateAddress",
			Handler:    _Block_ValidateAddress_Handler,
		},
		{
			MethodName: "GetTokenBalance",
			Handler:    _Block_GetTokenBalance_Handler,
		},
		{
			MethodName: "GetTokenBalanceBatch",
			Handler:    _Block_GetTokenBalanceBatch_Handler,
		},
		{
			MethodName: "GetTokenInfo",
			Handler:    _Block_GetTokenInfo_Handler,
		},
		{
			MethodName: "GetTokenInfoBatch",
			Handler:    _Block_GetTokenInfoBatch_Handler,
		},
		{
			MethodName: "GetTokenPrice",
			Handler:    _Block_GetTokenPrice_Handler,
		},
		{
			MethodName: "GetTokenPriceBatch",
			Handler:    _Block_GetTokenPriceBatch_Handler,
		},
		{
			MethodName: "Swap",
			Handler:    _Block_Swap_Handler,
		},
		{
			MethodName: "Quote",
			Handler:    _Block_Quote_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _Block_Transfer_Handler,
		},
		{
			MethodName: "Approve",
			Handler:    _Block_Approve_Handler,
		},
		{
			MethodName: "SendTransaction",
			Handler:    _Block_SendTransaction_Handler,
		},
		{
			MethodName: "SendPrivateTransaction",
			Handler:    _Block_SendPrivateTransaction_Handler,
		},
		{
			MethodName: "CreateAddress",
			Handler:    _Block_CreateAddress_Handler,
		},
		{
			MethodName: "CreateAddressBatch",
			Handler:    _Block_CreateAddressBatch_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _Block_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetLiquidity",
			Handler:    _Block_GetLiquidity_Handler,
		},
		{
			MethodName: "GetPendingNonce",
			Handler:    _Block_GetPendingNonce_Handler,
		},
		{
			MethodName: "GetTokenSecurity",
			Handler:    _Block_GetTokenSecurity_Handler,
		},
		{
			MethodName: "GetTokenMedia",
			Handler:    _Block_GetTokenMedia_Handler,
		},
		{
			MethodName: "GetTokenPoolInfo",
			Handler:    _Block_GetTokenPoolInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block/v1/block.proto",
}
